--- block/cfq-iosched.c
+++ block/cfq-iosched.c
@@ -65,7 +65,7 @@
 static struct completion *ioc_gone;
 static DEFINE_SPINLOCK(ioc_gone_lock);
 
-static DEFINE_SPINLOCK(cic_index_lock);
+static DEFINE_SPINLOCK(cic_index_lock);	  	
 static DEFINE_IDA(cic_index_ida);
 
 #define CFQ_PRIO_LISTS		IOPRIO_BE_NR
@@ -130,14 +130,14 @@
 	unsigned long slice_end;
 	long slice_resid;
 	
-	/* pending metadata requests */
-	int meta_pending;
+	/* pending priority requests */
+	int prio_pending;
 	/* number of requests that are on the dispatch list or inside driver */
 	int dispatched;
 	
 	/* io prio of this group */
 	unsigned short ioprio, org_ioprio;
-	unsigned short ioprio_class, org_ioprio_class;
+	unsigned short ioprio_class;
 	
 	pid_t pid;
 	
@@ -684,8 +684,8 @@
 	if (rq_is_sync(rq1) != rq_is_sync(rq2))
 		return rq_is_sync(rq1) ? rq1 : rq2;
 	
-	if ((rq1->cmd_flags ^ rq2->cmd_flags) & REQ_META)
-		return rq1->cmd_flags & REQ_META ? rq1 : rq2;
+	if ((rq1->cmd_flags ^ rq2->cmd_flags) & REQ_PRIO)
+		return rq1->cmd_flags & REQ_PRIO ? rq1 : rq2;
 	
 	s1 = blk_rq_pos(rq1);
 	s2 = blk_rq_pos(rq2);
@@ -1214,6 +1214,9 @@
 	
 	hlist_del_init(&cfqg->cfqd_node);
 	
+	BUG_ON(cfqd->nr_blkcg_linked_grps <= 0);
+	cfqd->nr_blkcg_linked_grps--;
+	
 	/*
 	 * Put the reference taken at the time of creation so that when all
 	 * queues are gone, group can be destroyed.
@@ -1609,9 +1612,9 @@
 	cfqq->cfqd->rq_queued--;
 	cfq_blkiocg_update_io_remove_stats(&(RQ_CFQG(rq))->blkg,
 									   rq_data_dir(rq), rq_is_sync(rq));
-	if (rq->cmd_flags & REQ_META) {
-		WARN_ON(!cfqq->meta_pending);
-		cfqq->meta_pending--;
+	if (rq->cmd_flags & REQ_PRIO) {
+		WARN_ON(!cfqq->prio_pending);
+		cfqq->prio_pending--;
 	}
 }
 
@@ -3166,8 +3168,8 @@
 		cic->key = cfqd;
 		
 		spin_lock_irqsave(&ioc->lock, flags);
-		ret = radix_tree_insert(&ioc->radix_root,
-								cfqd->cic_index, cic);
+		ret = radix_tree_insert(&ioc->radix_root,	  	
+				cfqd->cic_index, cic);
 		if (!ret)
 			hlist_add_head_rcu(&cic->cic_list, &ioc->cic_list);
 		spin_unlock_irqrestore(&ioc->lock, flags);
@@ -3443,8 +3445,8 @@
 	struct cfq_io_context *cic = RQ_CIC(rq);
 	
 	cfqd->rq_queued++;
-	if (rq->cmd_flags & REQ_META)
-		cfqq->meta_pending++;
+	if (rq->cmd_flags & REQ_PRIO)
+		cfqq->prio_pending++;
 	
 	cfq_update_io_thinktime(cfqd, cfqq, cic);
 	cfq_update_io_seektime(cfqd, cfqq, rq);
@@ -3696,7 +3674,6 @@
 	cfqq = cic_to_cfqq(cic, rw_is_sync(rw));
 	if (cfqq) {
 		cfq_init_prio_data(cfqq, cic->ioc);
-		cfq_prio_boost(cfqq);
 		
 		return __cfq_may_queue(cfqq);
 	}
@@ -3948,9 +3925,9 @@
 	spin_unlock_irq(q->queue_lock);
 	
 	cfq_shutdown_timer_wq(cfqd);
-	
-	spin_lock(&cic_index_lock);
-	ida_remove(&cic_index_ida, cfqd->cic_index);
+
+	spin_lock(&cic_index_lock);	  	
+	ida_remove(&cic_index_ida, cfqd->cic_index);	  	
 	spin_unlock(&cic_index_lock);
 	
 	/*
@@ -3974,22 +3951,21 @@
 	kfree(cfqd);
 }
 
-static int cfq_alloc_cic_index(void)
-{
+static int cfq_alloc_cic_index(void)	  	
+{	  	
 	int index, error;
-	
-	do {
-		if (!ida_pre_get(&cic_index_ida, GFP_KERNEL))
+	  	
+	do {	  	
+		if (!ida_pre_get(&cic_index_ida, GFP_KERNEL))	  	
 			return -ENOMEM;
-		
-		spin_lock(&cic_index_lock);
-		error = ida_get_new(&cic_index_ida, &index);
-		spin_unlock(&cic_index_lock);
-		if (error && error != -EAGAIN)
-			return error;
-	} while (error);
-	
-	return index;
+	  	
+		spin_lock(&cic_index_lock);	  	
+		error = ida_get_new(&cic_index_ida, &index);	  	
+		spin_unlock(&cic_index_lock);	  	
+		if (error && error != -EAGAIN)	  	
+			return error;	  	
+		} while (error);	  		  	
+	return index;	  	
 }
 
 static void *cfq_init_queue(struct request_queue *q)
@@ -3999,22 +3975,22 @@
 	struct cfq_group *cfqg;
 	struct cfq_rb_root *st;
 	
-	i = cfq_alloc_cic_index();
-	if (i < 0)
+	i = cfq_alloc_cic_index();	  	
+	if (i < 0)	  	
 		return NULL;
 	
 	cfqd = kmalloc_node(sizeof(*cfqd), GFP_KERNEL | __GFP_ZERO, q->node);
-	if (!cfqd) {
-		spin_lock(&cic_index_lock);
-		ida_remove(&cic_index_ida, i);
+	if (!cfqd) {	  	
+		spin_lock(&cic_index_lock);	  	
+		ida_remove(&cic_index_ida, i);	  	
 		spin_unlock(&cic_index_lock);
 		return NULL;
 	}
-	
-	/*
-	 * Don't need take queue_lock in the routine, since we are
-	 * initializing the ioscheduler, and nobody is using cfqd
-	 */
+	  	
+	   /*	  	
+		* Don't need take queue_lock in the routine, since we are	  	
+		* initializing the ioscheduler, and nobody is using cfqd	  	
+		*/	  	
 	cfqd->cic_index = i;
 	
 	/* Init root service tree */
